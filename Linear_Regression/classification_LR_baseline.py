import pandas as pd
import seaborn as sns
import numpy as np

#SKLEARN IMPORTS
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, confusion_matrix, roc_curve
import matplotlib.pyplot as plt





print("--- Starting Baseline Classification Pipeline ---")
# 1. LOAD THE FINAL DATAFRAME WITH FEATURES
# Make sure that 'df_with_all_features.csv' has been correctly generated by main_analysis.py
try:
    df_final = pd.read_csv('df_with_all_features.csv')
    print(f"DataFrame 'df_with_all_features.csv' loaded successfully. Rows: {len(df_final)}")
except FileNotFoundError:
    print("Error: 'df_with_all_features.csv' not found. Make sure you have run 'main_analysis.py' first.")
    exit()
except Exception as e:
    print(f"Error while loading the DataFrame: {e}")
    exit()

# Remove rows with NaN values in the features used for the baseline
features_for_baseline = [
    'rotational_asymmetry_score', 'compactness_score',
    'mean_color_B', 'mean_color_G', 'mean_color_R',
    'std_color_B', 'std_color_G', 'std_color_R' 
]

# Check if the columns exist in the DataFrame
missing_features = [f for f in features_for_baseline if f not in df_final.columns]
if missing_features:
    print(f"Error: The following baseline features were not found in the DataFrame: {missing_features}")
    print("Make sure that 'features_extractor.py' and 'main_analysis.py' are generating them correctly.")
    exit()

# Filter the DataFrame by removing rows with NaN in the relevant features
df_baseline = df_final.dropna(subset=features_for_baseline)
print(f"Rows after removing NaNs in ABC features: {len(df_baseline)}")

if df_baseline.empty:
    print("No valid data remains after removing NaNs. Unable to proceed with classification.")
    exit()



# 2. PREPARE DATA FOR THE MODEL

# X: Features (ABC)
X = df_baseline[features_for_baseline]

# y: Target label (melanoma vs non_melanoma)
# Convert 'melanoma' to 1 and 'non_melanoma' to 0
y = df_baseline['label'].apply(lambda x: 1 if x == 'melanoma' else 0)

print(f"\nClass distribution in the baseline dataset (1=melanoma, 0=non_melanoma):\n{y.value_counts()}")



# 3. SPLIT THE DATASET INTO TRAINING AND TEST SETS
# Use 20% of the data for testing, stratifying to maintain class proportions
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

print(f"\nTraining set sizes: X={X_train.shape}, y={y_train.shape}")
print(f"Test set sizes: X={X_test.shape}, y={y_test.shape}")



# 4. STANDARDIZE THE FEATURES
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

print("\nFeatures standardized.")



# 5. TRAIN THE BASELINE MODEL (LOGISTIC REGRESSION)
# Logistic Regression is a great baseline model for its simplicity and interpretability
model = LogisticRegression(random_state=42, solver='liblinear', class_weight='balanced')
model.fit(X_train_scaled, y_train)

print("\nBaseline model (Logistic Regression) trained.")



# 6. MODEL EVALUATION
y_pred = model.predict(X_test_scaled)
y_prob = model.predict_proba(X_test_scaled)[:, 1] # Probability of the positive class (melanoma)

print("\n--- Baseline Model Evaluation Metrics ---")
print(f"Accuracy: {accuracy_score(y_test, y_pred):.4f}")
print(f"Precision (Melanoma): {precision_score(y_test, y_pred, pos_label=1):.4f}")
print(f"Recall (Melanoma): {recall_score(y_test, y_pred, pos_label=1):.4f}")
print(f"F1-Score (Melanoma): {f1_score(y_test, y_pred, pos_label=1):.4f}")
print(f"ROC-AUC Score: {roc_auc_score(y_test, y_prob):.4f}")


# 7. VISUALIZE THE RESULTS - PLOTS
# Confusion Matrix
cm = confusion_matrix(y_test, y_pred)
print("\nConfusion Matrix:")
print(cm)

# Confusion Matrix Visualization
plt.figure(figsize=(6, 5))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', cbar=False,
            xticklabels=['Non-Melanoma (0)', 'Melanoma (1)'],
            yticklabels=['Non-Melanoma (0)', 'Melanoma (1)'])
plt.title('Confusion Matrix - Baseline Model')
plt.xlabel('Predicted')
plt.ylabel('True')
plt.show()

# ROC Curve
fpr, tpr, thresholds = roc_curve(y_test, y_prob)
plt.figure(figsize=(7, 6))
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC Curve (AUC = {roc_auc_score(y_test, y_prob):.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate (FPR)')
plt.ylabel('True Positive Rate (TPR)')
plt.title('ROC Curve - Baseline Model')
plt.legend(loc='lower right')
plt.grid(True)
plt.show()

print("\n--- Baseline Classification Pipeline Completed ---")
